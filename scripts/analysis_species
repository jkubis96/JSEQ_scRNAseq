#!/bin/bash 


# loading configs & paths

source $(pwd)/requirements_file/barcodes
source $(pwd)/requirements_file/config_tools.conf
CHECK=$(pwd)/projects/$project_name_mode
RESULT=$(pwd)/projects/$project_name_mode/results/
ADAPTERS=$(pwd)/requirements_file/Adapters.fa
INFASTP=$(pwd)/projects/$project_name_mode/fast_data
tmp=$(pwd)/projects/$project_name_mode/tmp
SCRIPTS_EXTRACT=$(pwd)/scripts


function TRIMMING {

echo Trimming Start



if ! [[ -f $CHECK/fast_data/R1_out_exctracted.fastq.gz || -f $CHECK/sc_data/matrix.mtx ]];
then

	for i in $INFASTP/*.fastq.gz;
	do
	if       [[ $i == *"input_R1"* ]];
	then
			R1=$i
		R1_NAME=$(basename $i)
	elif
			[[ $i == *"input_R2"* ]];
	then
			R2=$i
		R2_NAME=$(basename $i)
	else
			echo 'Not fastq'

	fi
	done;
	
	source $(pwd)/requirements_file/genome.conf
	qc_reads=$qc_reads
	
	cd $INFASTP


	if [[ $qc_reads == *"ON"* ]];
	then

	fastp -i $R1_NAME -I $R2_NAME -o R1_out.fastq.gz -O R2_out.fastq.gz --adapter_fasta $ADAPTERS --trim_poly_x --length_required $[$umi_length + $barcode_length]  --html $RESULT/QC_RAPORT.html 
	
	elif [[ $qc_reads == *"OFF"* ]];
	then

	fastp -i $R1_NAME -I $R2_NAME -o R1_out.fastq.gz -O R2_out.fastq.gz --adapter_fasta $ADAPTERS -Q --trim_poly_x --length_required $[$umi_length + $barcode_length]  --html $RESULT/QC_RAPORT.html 
	
	fi


	cd ..
	cd ..
	cd ..

else 

	echo 'Trimming was done before'
	
fi

}


function whitelist {


if ! [[ -f $CHECK/tmp/whitelist_barcodes.csv || -f $CHECK/sc_data/matrix.mtx ]];
then




	for i in $INFASTP/*.fastq.gz;
	do
	if       [[ $i == *"R1_out"* ]];
	then
			R1_out=$i
			R1_NAME_out=$(basename $i)
	elif
			[[ $i == *"R2_out"* ]];
	then
			R2=$i
			R2_NAME_out=$(basename $i)
	else
			echo 'Next step =>'
	fi
	done;


	cd $(pwd)/projects/$project_name_mode/fast_data

	
	if [[ $BU_READ == *"1"* ]];
	then

		umi_tools whitelist --stdin $R1_NAME_out --bc-pattern=$barcode --extract-method=regex --set-cell-number=$cell --error-correct-threshold=$error_threshold --ed-above-threshold=discard --plot-prefix=$RESULT/expect_whitelist --log2stderr > $tmp/whitelist.csv ;
		umi_tools extract --bc-pattern=$barcode --extract-method=regex --stdin=$R1_NAME_out --stdout=R1_out_extracted.fastq.gz --read2-in=$R2_NAME_out --read2-out=R2_out_extracted.fastq.gz --error-correct-cell --reconcile-pairs  --whitelist=$tmp/whitelist.csv
		gunzip R2_out_extracted.fastq.gz
		rm R1_out_extracted.fastq.gz

	elif [[ $BU_READ == *"2"* ]];
	then

		umi_tools whitelist --stdin $R2_NAME_out --bc-pattern=$barcode --extract-method=regex --set-cell-number=$cell --error-correct-threshold=$error_threshold --ed-above-threshold=discard --plot-prefix=$RESULT/expect_whitelist --log2stderr > $tmp/whitelist.csv ;
		umi_tools extract --bc-pattern=$barcode --extract-method=regex --stdin=$R2_NAME_out --stdout=R2_out_extracted.fastq.gz --read2-in=$R1_NAME_out --read2-out=R1_out_extracted.fastq.gz --error-correct-cell --reconcile-pairs  --whitelist=$tmp/whitelist.csv
		gunzip R1_out_extracted.fastq.gz
		rm R2_out_extracted.fastq.gz

	fi

	cat $tmp/whitelist.csv | cut -f 1 > $tmp/whitelist_barcodes.csv ;

	cell=`cat $tmp/whitelist_barcodes.csv  | wc -l`

	echo 'Cells detected - ' $cell

	rm R1_out.fastq.gz
	
	cd ..
	cd ..
	cd ..
	
else 

	echo 'Whitelist was done before'
	
fi


}




function STAR_MAPPING {

echo Mapping Start


if ! [[ -f $CHECK/tmp/Aligned.out.bam || -f $CHECK/sc_data/matrix.mtx ]];
then


	cpu=$(grep -c ^processor /proc/cpuinfo)
	cpu=$[$cpu-2]
	DIR=$(pwd)/genome/$species/index/$READS_LENGHT 


	for i in $INFASTP/*.fastq;
	do
	if       [[ $i == *"R1_out_extracted"* ]];
	then
			R1_map=$i
			R1_NAME_map=$(basename $i)
	elif
			[[ $i == *"R2_out_extracted"* ]];
	then
			R2_map=$i
			R2_NAME_map=$(basename $i)
	else
        echo 'Next step =>'
	fi
	done;


	if [[ $BU_READ == *"1"* ]];
	then

		R2_FILE=$INFASTP'/'$R2_NAME_map
		STAR --outReadsUnmapped Fastx --outFilterMismatchNmax $outFilterMismatchNmax --outSAMtype BAM Unsorted --outFilterMultimapNmax $outFilterMultimapNmax --outFilterMismatchNoverLmax $outFilterMismatchNoverLmax --outFilterMismatchNoverReadLmax $outFilterMismatchNoverReadLmax --outFilterMatchNmin $outFilterMatchNmin --outFilterScoreMinOverLread $outFilterScoreMinOverLread --outFilterMatchNminOverLread $outFilterMatchNminOverLread  --runThreadN $cpu --genomeDir $DIR --readFilesIn $R2_FILE --outFileNamePrefix $tmp --outStd Log  > $RESULT/Log.final.out 2>&1
		rm R2_FILE


	elif [[ $BU_READ == *"2"* ]];
	then

		R1_FILE=$INFASTP'/'$R1_NAME_map
		STAR --outReadsUnmapped Fastx --outFilterMismatchNmax $outFilterMismatchNmax --outSAMtype BAM Unsorted --outFilterMultimapNmax $outFilterMultimapNmax --outFilterMismatchNoverLmax $outFilterMismatchNoverLmax --outFilterMismatchNoverReadLmax $outFilterMismatchNoverReadLmax --outFilterMatchNmin $outFilterMatchNmin --outFilterScoreMinOverLread $outFilterScoreMinOverLread --outFilterMatchNminOverLread $outFilterMatchNminOverLread  --runThreadN $cpu --genomeDir $DIR --readFilesIn $R1_FILE --outFileNamePrefix $tmp --outStd Log  > $RESULT/Log.final.out 2>&1
		rm R1_FILE

	fi

else 

	echo 'Mapping was done before'
	
fi


}

function add_tags {


if ! [[ -f $CHECK/tmp/final.bam || -f $CHECK/sc_data/matrix.mtx ]];
then

	samtools view -h $tmp/*.out.bam | sed 's/_/XC:Z:/' | grep -oE "XC:Z:[acgtnACGTN-]+" > $tmp/barcodes.sam
	samtools view -h $tmp/*.out.bam | sed 's/_/XC:Z:/' | sed 's/_/XM:Z:/' | grep -oE "XM:Z:[acgtnACGTN-]+" > $tmp/umis.sam

	python3 $SCRIPTS_EXTRACT/add_tags.py $tmp/barcodes.sam $tmp/umis.sam $tmp/*.out.bam $tmp/final.bam $barcode_length $umi_length
	
	rm $CHECK/tmp/Aligned.out.bam
	rm $tmp/barcodes.sam
	rm $tmp/umis.sam

else 

	echo 'Tags were added before'
	
fi


}





function dropSEQ {


if ! [[ -f $CHECK/tmp/gene_exon_tagged.bam || -f $CHECK/sc_data/matrix.mtx ]];
then

	java -jar /tools/DropSeq/jar/dropseq.jar TagReadWithGeneFunction \
			INPUT=$(pwd)/projects/$project_name_mode/tmp/final.bam \
			OUTPUT=$(pwd)/projects/$project_name_mode/tmp/gene_exon_tagged.bam \
			ANNOTATIONS_FILE=$(pwd)/genome/$species/correct_annotation.refFlat 
	
	rm $CHECK/tmp/final.bam

else 

	echo 'TagGene was done before'
	
fi


}

function final_exon {


if ! [[ -f $CHECK/tmp/gene_exon_tagged_error.bam || -f $CHECK/sc_data/matrix.mtx ]];
then
	cpu=$(grep -c ^processor /proc/cpuinfo)
	cpu=$[$cpu-2]

	java -jar /tools/DropSeq/jar/dropseq.jar DetectBeadSubstitutionErrors \
			I=$(pwd)/projects/$project_name_mode/tmp/gene_exon_tagged.bam \
			O=$(pwd)/projects/$project_name_mode/tmp/gene_exon_tagged_error.bam \
			OUTPUT_REPORT=$(pwd)/projects/$project_name_mode/tmp/beadSubstitutionReport.txt \
			OUTPUT_SUMMARY=$(pwd)/projects/$project_name_mode/tmp/beadSubstitutionSummary.txt \
			NUM_THREADS=$cpu

	rm $CHECK/tmp/gene_exon_tagged.bam

else 

	echo 'Barcodes repair was done before'
	
fi


}

function completed_bam {


if ! [[ -f $CHECK/results/Completed.bam || -f $CHECK/sc_data/matrix.mtx ]];
then

	cell=`cat $tmp/whitelist_barcodes.csv  | wc -l`
	cpu=$(grep -c ^processor /proc/cpuinfo)
	cpu=$[$cpu-2]

	source $(pwd)/requirements_file/smart_primer

	java -jar /tools/DropSeq/jar/dropseq.jar DetectBeadSynthesisErrors \
			INPUT=$(pwd)/projects/$project_name_mode/tmp/gene_exon_tagged_error.bam \
			OUTPUT=$(pwd)/projects/$project_name_mode/results/Completed.bam \
			OUTPUT_STATS=$(pwd)/projects/$project_name_mode/tmp/synthesis_stats.txt \
			SUMMARY=$(pwd)/projects/$project_name_mode/tmp/synthesis_stats_summary.txt \
			NUM_BARCODES=$cell \
			PRIMER_SEQUENCE=$smart \
			NUM_THREADS=$cpu

	rm $CHECK/tmp/gene_exon_tagged_error.bam

else 

	echo 'SynthesisError was done before'
	
fi


}



##EXPRESSION FILE AND STATS
function umi_extract {


if ! [[ -f $CHECK/tmp/selected_cells.sc || -f $CHECK/sc_data/matrix.mtx ]];
then
	#
	samtools view $RESULT/Completed.bam | grep -oE "XC:Z:[acgtnACGTN-]+" > $tmp/repaired_barcodes.sam
	cat $tmp/repaired_barcodes.sam | sort | uniq -c | sort -nr | sed 's/XC:Z:/\t/' > $tmp/barcode_stat.txt
	# awk '{if($1 > $umi_deep) print $2}' $tmp/barcode_stat.txt > $tmp/selected_cells.sc
	awk 'NR==FNR {whitelist[$1]; next} ($1 > $umi_deep) && ($2 in whitelist) {print $2}' $tmp/whitelist_barcodes.csv $tmp/barcode_stat.txt $tmp/selected_cells.sc
	rm $tmp/repaired_barcodes.sam

else 

	echo 'UMI extraction was done before'
	
fi


}

function umi_expression {


if ! [[ -f $CHECK/tmp/umi_expression.tsv || -f $CHECK/sc_data/matrix.mtx ]];
then

	java -jar /tools/DropSeq/jar/dropseq.jar DigitalExpression \
			I=$(pwd)/projects/$project_name_mode/results/Completed.bam \
			O=$(pwd)/projects/$project_name_mode/tmp/umi_expression.tsv \
			EDIT_DISTANCE=$EDIT_DISTANCE \
			OUTPUT_LONG_FORMAT=$(pwd)/projects/$project_name_mode/tmp/umi_expression.long \
			STRAND_STRATEGY=$STRAND_STRATEGY \
			OUTPUT_READS_INSTEAD=$OUTPUT_READS_INSTEAD \
			LOCUS_FUNCTION_LIST=$LOCUS_FUNCTION_LIST \
			MIN_BC_READ_THRESHOLD=$MIN_BC_READ_THRESHOLD \
			CELL_BC_FILE=$(pwd)/projects/$project_name_mode/tmp/selected_cells.sc
			
else 

	echo 'DEG was done before'
	
fi


}


function scRNAmetrics {


if ! [[ -f $CHECK/tmp/scRNAmetrics.txt || -f $CHECK/sc_data/matrix.mtx ]];
then

	java -jar /tools/DropSeq/jar/dropseq.jar SingleCellRnaSeqMetricsCollector \
			INPUT=$(pwd)/projects/$project_name_mode/results/Completed.bam\
			OUTPUT=$(pwd)/projects/$project_name_mode/results/scRNAmetrics.txt\
			ANNOTATIONS_FILE=$(pwd)/genome/$species/correct_annotation.refFlat \
			CELL_BC_FILE=$(pwd)/projects/$project_name_mode/tmp/selected_cells.sc \
			RIBOSOMAL_INTERVALS=$(pwd)/genome/$species/annotation.rRNA.intervals
        
else 

	echo 'Metrics were done before'
	
fi	

}


function metric_plot {

if ! [[ -f $CHECK/sc_data/matrix.mtx ]];
then


	Rscript $SCRIPTS_EXTRACT/rna_metrics.R $RESULT $RESULT

else 

	echo 'Plot was done before'
	
fi

}




function convert_mtx_umi {

if ! [[ -f $CHECK/sc_data/matrix.mtx ]];
then

	path_convert=$(pwd)/projects/$project_name_mode/sc_data
	mkdir -p $path_convert
	path_tmp_mtx=$(pwd)/projects/$project_name_mode/tmp

	format=tsv
	con=raw
	null=NULL
	converter=$(pwd)/scripts/converter.R
	Rscript $converter $format $path_convert $null $path_tmp_mtx $con

	rm -rf $PATH_PROJECT/tmp
	
else 

	echo 'Conversion was done before'
	
fi

}


function seurat {

PATH_PROJECT=$(pwd)/projects/$project_name_mode
MARKERS=$marker_path
data=3

CHECK=$(pwd)/projects/$project_name_mode/sc_data

if [[ -f $CHECK/matrix.mtx ]];
then	

	Rscript $SCRIPTS_EXTRACT/seurat_cluster_species.R $PATH_PROJECT $MARKERS $species $project_name $data $cell

	cp $SCRIPTS_EXTRACT/manual_species.R $PATH_PROJECT/results
	mv $PATH_PROJECT/results/manual_species.R $PATH_PROJECT/results/manual_analysis.R 

	rm -rf $PATH_PROJECT/results/HDMAP_subtypes_files
	rm -rf $PATH_PROJECT/results/UMAP_with_DE_gene_subtypes_files


fi


}
